"""unique constraints changes for gateways/tools/serv

Revision ID: e182847d89e6
Revises: cfc3d6aa0fb2
Create Date: 2025-09-12 12:55:17.537176

"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import sqlite

# revision identifiers, used by Alembic.
revision: str = "e182847d89e6"
down_revision: Union[str, Sequence[str], None] = "cfc3d6aa0fb2"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    bind = op.get_bind()
    inspector = sa.inspect(bind)
    # ### commands auto generated by Alembic - please adjust! ###
    for tbl, constraints in {
        "servers": [("name", "uq_team_owner_name_servers")],
        "tools": [("name", "uq_team_owner_name_tools")],
        "gateways": [("slug", "uq_team_owner_slug_gateway"), ("url", "uq_team_owner_url_gateway")],
    }.items():
        try:
            print(f"Processing {tbl} for unique constraint update...")
            columns = inspector.get_columns(tbl)
            column_defs = []
            column_names = []
            pk_constraint = None
            fk_constraints = inspector.get_foreign_keys(tbl)
            unique_constraints = inspector.get_unique_constraints(tbl)
            for c in columns:
                col_def = f"{c['name']} {str(c['type'])}" + (" NOT NULL" if not c.get("nullable", True) else "")
                column_defs.append(col_def)
                column_names.append(c["name"])
                if c.get("primary_key", False):
                    pk_constraint = c["name"]
            constraints_sql = []
            if pk_constraint:
                constraints_sql.append(f"PRIMARY KEY ({pk_constraint})")
            for fk in fk_constraints:
                fk_cols = ", ".join(fk["constrained_columns"])
                ref_table = fk["referred_table"]
                ref_cols = ", ".join(fk["referred_columns"])
                fk_name = fk.get("name")
                if fk_name and fk_name != "None":
                    constraints_sql.append(f"CONSTRAINT {fk_name} FOREIGN KEY ({fk_cols}) REFERENCES {ref_table} ({ref_cols})")
                else:
                    constraints_sql.append(f"FOREIGN KEY ({fk_cols}) REFERENCES {ref_table} ({ref_cols})")
            for uq in unique_constraints:
                uq_cols = ", ".join(uq["column_names"])
                uq_name = uq.get("name")
                # Only add unique constraints not being replaced
                if uq_name and uq_name != "None" and all(uq_name != c[1] for c in constraints):
                    constraints_sql.append(f"CONSTRAINT {uq_name} UNIQUE ({uq_cols})")
            tmp_table = f"{tbl}_tmp_nounique"
            all_defs = column_defs + constraints_sql
            op.execute(f"DROP TABLE IF EXISTS {tmp_table}")
            op.execute(f"CREATE TABLE {tmp_table} ({', '.join(all_defs)})")
            op.execute(f"INSERT INTO {tmp_table} SELECT {', '.join(column_names)} FROM {tbl}")
            with op.batch_alter_table(tmp_table, schema=None) as batch_op:
                for col, constraint_name in constraints:
                    cols = ["team_id", "owner_email", col]
                    batch_op.create_unique_constraint(constraint_name, cols)
            op.drop_table(tbl)
            op.execute(f"ALTER TABLE {tmp_table} RENAME TO {tbl}")
        except Exception as e:
            print(f"Warning: Could not update unique constraint on {tbl} table: {e}")
        # ### end Alembic commands ###


def downgrade() -> None:
    # """Downgrade schema."""
    bind = op.get_bind()
    inspector = sa.inspect(bind)
    for tbl, constraints in {
        "servers": [("name", "uq_team_owner_name_servers", "None")],
        "tools": [("name", "uq_team_owner_name_tools", "None")],
        "gateways": [("slug", "uq_team_owner_slug_gateway", "None"), ("url", "uq_team_owner_url_gateway", "None")],
    }.items():
        try:
            print(f"Processing {tbl} for unique constraint revert...")
            columns = inspector.get_columns(tbl)
            column_defs = []
            column_names = []
            pk_constraint = None
            fk_constraints = inspector.get_foreign_keys(tbl)
            unique_constraints = inspector.get_unique_constraints(tbl)
            for c in columns:
                col_def = f"{c['name']} {str(c['type'])}" + (" NOT NULL" if not c.get("nullable", True) else "")
                column_defs.append(col_def)
                column_names.append(c["name"])
                if c.get("primary_key", False):
                    pk_constraint = c["name"]
            constraints_sql = []
            if pk_constraint:
                constraints_sql.append(f"PRIMARY KEY ({pk_constraint})")
            for fk in fk_constraints:
                fk_cols = ", ".join(fk["constrained_columns"])
                ref_table = fk["referred_table"]
                ref_cols = ", ".join(fk["referred_columns"])
                fk_name = fk.get("name")
                if fk_name and fk_name != "None":
                    constraints_sql.append(f"CONSTRAINT {fk_name} FOREIGN KEY ({fk_cols}) REFERENCES {ref_table} ({ref_cols})")
                else:
                    constraints_sql.append(f"FOREIGN KEY ({fk_cols}) REFERENCES {ref_table} ({ref_cols})")
            for uq in unique_constraints:
                uq_cols = ", ".join(uq["column_names"])
                uq_name = uq.get("name")
                # Only add unique constraints not being reverted

                if uq_name and uq_name != "None" and all(uq_name != c[1] for c in constraints):
                    constraints_sql.append(f"CONSTRAINT {uq_name} UNIQUE ({uq_cols})")
                elif not uq_name and uq_name != constraint_name:
                    constraints_sql.append(f"UNIQUE ({uq_cols})")
            for col, constraint, old_constraint in constraints:
                constraints_sql.append(f"UNIQUE ({col})")
            tmp_table = f"{tbl}_tmp_nounique"
            all_defs = column_defs + constraints_sql
            op.execute(f"DROP TABLE IF EXISTS {tmp_table}")
            op.execute(
                f"""
    CREATE TABLE {tmp_table} (
        {',\n    '.join(all_defs)}
    )
    """
            )
            op.execute(f"INSERT INTO {tmp_table} SELECT {', '.join(column_names)} FROM {tbl}")
            op.drop_table(tbl)
            op.execute(f"ALTER TABLE {tmp_table} RENAME TO {tbl}")
        except Exception as e:
            print(f"Warning: Could not revert unique constraint on {tbl} table: {e}")
    # ### end Alembic commands ###
