// Copyright 2025
// SPDX-License-Identifier: Apache-2.0
//
// Rust-accelerated plugins for MCP Gateway
// Built with PyO3 for seamless Python integration

// Allow non-local definitions for PyO3 macros (known issue with PyO3 0.20.x)
#![allow(non_local_definitions)]

use pyo3::prelude::*;
use regex::Regex;
use serde_json::{json, Value};

// Re-export the pii_filter library (note: lib name is pii_filter_rust in Cargo.toml)
pub use pii_filter_rust as pii_filter;

fn json_schema_to_typescript_type(schema: &Value) -> String {
    if let Some(enum_values) = schema.get("enum").and_then(Value::as_array) {
        let parts: Vec<String> = enum_values
            .iter()
            .map(|v| serde_json::to_string(v).unwrap_or_else(|_| "null".to_string()))
            .collect();
        if parts.is_empty() {
            return "any".to_string();
        }
        return parts.join(" | ");
    }

    match schema.get("type").and_then(Value::as_str).unwrap_or("any") {
        "string" => "string".to_string(),
        "integer" | "number" => "number".to_string(),
        "boolean" => "boolean".to_string(),
        "array" => {
            let item_ty = json_schema_to_typescript_type(schema.get("items").unwrap_or(&Value::Null));
            format!("{}[]", item_ty)
        }
        "object" => {
            let props = schema
                .get("properties")
                .and_then(Value::as_object)
                .cloned()
                .unwrap_or_default();
            let required: Vec<String> = schema
                .get("required")
                .and_then(Value::as_array)
                .map(|arr| arr.iter().filter_map(|v| v.as_str().map(str::to_string)).collect())
                .unwrap_or_default();
            if props.is_empty() {
                return "Record<string, any>".to_string();
            }
            let mut parts: Vec<String> = Vec::new();
            for (k, v) in props {
                let optional = if required.iter().any(|r| r == &k) { "" } else { "?" };
                let ty = json_schema_to_typescript_type(&v);
                parts.push(format!("{}{}: {};", k, optional, ty));
            }
            format!("{{ {} }}", parts.join(" "))
        }
        _ => "any".to_string(),
    }
}

fn json_schema_to_python_type(schema: &Value) -> String {
    if let Some(enum_values) = schema.get("enum").and_then(Value::as_array) {
        let parts: Vec<String> = enum_values
            .iter()
            .map(|v| {
                if let Some(s) = v.as_str() {
                    format!("\"{}\"", s)
                } else {
                    v.to_string()
                }
            })
            .collect();
        if parts.is_empty() {
            return "Any".to_string();
        }
        return format!("Literal[{}]", parts.join(", "));
    }

    match schema.get("type").and_then(Value::as_str).unwrap_or("any") {
        "string" => "str".to_string(),
        "integer" => "int".to_string(),
        "number" => "float".to_string(),
        "boolean" => "bool".to_string(),
        "array" => {
            let item_ty = json_schema_to_python_type(schema.get("items").unwrap_or(&Value::Null));
            format!("List[{}]", item_ty)
        }
        "object" => "Dict[str, Any]".to_string(),
        _ => "Any".to_string(),
    }
}

/// Build TypeScript + Python tool stubs from JSON Schema input schema.
#[pyfunction]
fn json_schema_to_stubs(
    schema_json: &str,
    server_slug: &str,
    tool_name: &str,
    description: Option<&str>,
) -> PyResult<String> {
    let schema: Value = serde_json::from_str(schema_json).map_err(|e| {
        PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("Invalid JSON schema: {}", e))
    })?;

    let safe_description = description.unwrap_or("").replace("*/", "* /").replace("\"\"\"", "\\\"\\\"\\\"");
    let fn_name = tool_name.replace('-', "_");
    let ts_args = json_schema_to_typescript_type(&schema);
    let py_args = json_schema_to_python_type(&schema);

    let ts_stub = format!(
        "// Auto-generated by plugins_rust::json_schema_to_stubs.\\n\
import {{ type ToolResult }} from \\\"/tools/_runtime.ts\\\";\\n\\n\
/**\\n * {}\\n * @server {}\\n */\\n\
export async function {}(args: {}): Promise<ToolResult<any>> {{\\n\
  return __toolcall__(\\\"{}\\\", \\\"{}\\\", args);\\n\
}}\\n",
        safe_description, server_slug, fn_name, ts_args, server_slug, fn_name
    );

    let py_stub = format!(
        "# Auto-generated by plugins_rust::json_schema_to_stubs.\\n\
from __future__ import annotations\\n\
from typing import Any, Dict, List, Literal\\n\
from tools._runtime import toolcall\\n\\n\
async def {}(args: {}) -> Any:\\n\
    \\\"\\\"\\\"{}\\\"\\\"\\\"\\n\
    return await toolcall(\\\"{}\\\", \\\"{}\\\", args)\\n",
        fn_name, py_args, safe_description, server_slug, fn_name
    );

    Ok(json!({"typescript": ts_stub, "python": py_stub}).to_string())
}

/// Normalize and sort catalog payloads for deterministic output.
#[pyfunction]
fn catalog_builder(catalog_json: &str) -> PyResult<String> {
    let mut value: Value = serde_json::from_str(catalog_json).map_err(|e| {
        PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("Invalid catalog JSON: {}", e))
    })?;

    if let Some(tools) = value.get_mut("tools").and_then(Value::as_array_mut) {
        tools.sort_by(|a, b| {
            let a_name = a.get("name").and_then(Value::as_str).unwrap_or("");
            let b_name = b.get("name").and_then(Value::as_str).unwrap_or("");
            a_name.cmp(b_name)
        });
    }
    Ok(value.to_string())
}

/// Search an in-memory index string (`path:content` per line) with regex.
#[pyfunction]
fn fs_search(index_blob: &str, pattern: &str) -> PyResult<Vec<String>> {
    let regex = Regex::new(pattern).map_err(|e| {
        PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("Invalid regex pattern: {}", e))
    })?;
    let mut matches: Vec<String> = Vec::new();
    for line in index_blob.lines() {
        let mut parts = line.splitn(2, ':');
        let path = parts.next().unwrap_or("");
        let content = parts.next().unwrap_or("");
        if regex.is_match(path) || regex.is_match(content) {
            matches.push(path.to_string());
        }
    }
    Ok(matches)
}

/// Python module: plugins_rust
///
/// High-performance Rust implementations of MCP Gateway plugins.
/// Provides 5-10x speedup over pure Python implementations.
///
/// # Examples
///
/// ```python
/// from plugins_rust import PIIDetectorRust
///
/// # Create detector with configuration
/// config = {
///     "detect_ssn": True,
///     "detect_credit_card": True,
///     "default_mask_strategy": "redact",
/// }
/// detector = PIIDetectorRust(config)
///
/// # Detect PII in text
/// text = "My SSN is 123-45-6789"
/// detections = detector.detect(text)
/// print(detections)  # {"ssn": [{"value": "123-45-6789", ...}]}
///
/// # Mask detected PII
/// masked = detector.mask(text, detections)
/// print(masked)  # "My SSN is [REDACTED]"
/// ```
#[pymodule]
fn plugins_rust(m: &Bound<'_, pyo3::types::PyModule>) -> PyResult<()> {
    // Export PII Filter Rust implementation
    m.add_class::<pii_filter_rust::PIIDetectorRust>()?;
    m.add_function(wrap_pyfunction!(json_schema_to_stubs, m)?)?;
    m.add_function(wrap_pyfunction!(catalog_builder, m)?)?;
    m.add_function(wrap_pyfunction!(fs_search, m)?)?;

    // Module metadata
    m.add("__version__", env!("CARGO_PKG_VERSION"))?;
    m.add(
        "__doc__",
        "High-performance Rust implementations of MCP Gateway plugins",
    )?;

    Ok(())
}
