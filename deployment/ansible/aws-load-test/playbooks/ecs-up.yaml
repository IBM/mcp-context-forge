---
- name: Create ECS services for MCP ContextForge
  hosts: "_bastion"
  environment:
    AWS_ACCESS_KEY_ID: "{{ access_key_v }}"
    AWS_SECRET_ACCESS_KEY: "{{ secret_key_v }}"
    AWS_REGION: "{{ region_v }}"
  vars:
    ansible_python_interpreter: /home/ubuntu/.venv/bin/python3
    debug_container_p: true
  tasks:
    - name: Get VPC private subnets
      amazon.aws.ec2_vpc_subnet_info:
        filters:
          "tag:Project": "{{ prefix_v }}"
          "map-public-ip-on-launch": false
      register: vpc_private_subnets_r

    - name: Get VPC public subnets
      amazon.aws.ec2_vpc_subnet_info:
        filters:
          "tag:Project": "{{ prefix_v }}"
          "map-public-ip-on-launch": true
      register: vpc_public_subnets_r

    - name: Get all security groups of interest
      amazon.aws.ec2_security_group_info:
        filters:
          group-name:
            - "{{ prefix_v }}-alb-sg"
            - "{{ prefix_v }}-ecs-tasks-sg"
      register: sg_r

    - name: Retrieve information about the RDS cluster
      amazon.aws.rds_cluster_info:
        cluster_id: "{{ prefix_v }}-mcf-postgres"
      register: rds_cluster_info_r

    - name: Get ElastiCache endpoint
      ansible.builtin.command: >
        aws elasticache describe-serverless-caches
        --serverless-cache-name {{ prefix_v }}-redis
        --region {{ region_v }}
        --query 'ServerlessCaches[0].Endpoint.Address'
        --output text
      register: elasticache_endpoint_r
      changed_when: false

    - name: Set ElastiCache facts
      ansible.builtin.set_fact:
        redis_auth_token: "{{ lookup('amazon.aws.secretsmanager_secret', prefix_v + '-redis-auth-token') }}"
        elasticache_endpoint: "{{ elasticache_endpoint_r.stdout }}"

    - name: Get AWS account ID
      ansible.builtin.command: aws sts get-caller-identity --query Account --output text --region {{ region_v }}
      register: aws_account_r
      changed_when: false

    - name: Set ECR registry URL
      ansible.builtin.set_fact:
        ecr_registry: "{{ aws_account_r.stdout }}.dkr.ecr.{{ region_v }}.amazonaws.com"

    - name: Set facts based on everything we've retrieved
      ansible.builtin.set_fact:
        alb_sg_group_id_f: >-
          {{ (sg_r.security_groups |
            selectattr('group_name', 'eq', prefix_v + '-alb-sg') |
            first).group_id
          }}
        ecs_ec2_sg_group_id_f: >-
          {{ (sg_r.security_groups |
            selectattr('group_name', 'eq', prefix_v + '-ecs-tasks-sg') |
            first).group_id
          }}

    - name: Create CloudWatch log group for MCF
      amazon.aws.cloudwatchlogs_log_group:
        log_group_name: /ecs/mcf
        state: present
        retention: 7

    - name: Create ECS cluster for Fargate
      community.aws.ecs_cluster:
        name: "{{ prefix_v }}-ecs-cluster"
        state: present
        capacity_providers:
          - FARGATE
          - FARGATE_SPOT
        capacity_provider_strategy:
          - capacity_provider: FARGATE
            weight: 1
            base: 1
      register: ecs_cluster_r

    - name: Create an execution role for the containers
      amazon.aws.iam_role:
        name: "{{ prefix_v }}-container-execution-role"
        assume_role_policy_document: |
            {
              "Version":"2012-10-17",
              "Statement": [
                {
                  "Sid": "",
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ecs-tasks.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            }
        managed_policies:
          - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        wait: true
      register: execution_role_r

    - name: Add Secrets Manager access policy to the execution role
      amazon.aws.iam_policy:
        iam_type: role
        iam_name: "{{ prefix_v }}-container-execution-role"
        policy_name: "{{ prefix_v }}-access-credentials"
        policy_json: |
            {
              "Version":"2012-10-17",
              "Statement": [
                  {
                      "Effect": "Allow",
                      "Action": [
                          "secretsmanager:GetSecretValue"
                      ],
                      "Resource": [
                          "arn:aws:secretsmanager:{{ region_v }}:*:secret:{{ prefix_v }}-*"
                      ]
                  }
              ]
            }

    - name: Create a task role for the containers
      amazon.aws.iam_role:
        name: "{{ prefix_v }}-container-task-role"
        assume_role_policy_document: |
            {
              "Version":"2012-10-17",
              "Statement": [
                {
                  "Sid": "",
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ecs-tasks.amazonaws.com"
                  },
                  "Action": [
                    "sts:AssumeRole"
                  ]
                }
              ]
            }
        managed_policies:
          - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        wait: true
      register: task_role_r

    - name: Create a policy to allow execute command in debug containers
      amazon.aws.iam_policy:
        state: present
        iam_type: role
        iam_name: "{{ task_role_r.iam_role.role_name }}"
        policy_name: "{{ prefix_v }}-execute-command-policy"
        policy_json: |
            {
              "Version":"2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "ssmmessages:CreateControlChannel",
                    "ssmmessages:CreateDataChannel",
                    "ssmmessages:OpenControlChannel",
                    "ssmmessages:OpenDataChannel"
                  ],
                  "Resource": "*"
                }
              ]
            }
      when: debug_container_p

    - name: Create Cloud Map namespace for service discovery
      cloudmap_namespace:
        state: present
        name: "{{ prefix_v }}.local"
        namespace_type: private
        vpc: "{{ vpc_private_subnets_r.subnets[0].vpc_id }}"
        description: |
            Service discovery namespace for {{ prefix_v }} ECS services
        tags:
          Name: "{{ prefix_v }}-ecs-namespace"
          Project: "{{ prefix_v }}"
        wait: true
        wait_timeout: 300
      register: cloudmap_namespace_r

    # ==========================================================================
    # Task Definitions
    # ==========================================================================

    - name: ECS Task Definition for gateway
      community.aws.ecs_taskdefinition:
        family: "{{ prefix_v }}-gateway-td"
        state: "present"
        launch_type: FARGATE
        memory: "8192"
        cpu: "4096"
        network_mode: awsvpc
        execution_role_arn: "{{ execution_role_r.iam_role.arn }}"
        task_role_arn: "{{ task_role_r.iam_role.arn }}"
        force_create: true
        containers:
          - name: gateway
            image: >-
              ghcr.io/ibm/mcp-context-forge:{{ gateway_image_tag_v | default('latest') }}
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: gateway
            environment:
              - name: HOST
                value: "0.0.0.0"
              - name: PORT
                value: "4444"
              - name: HTTP_SERVER
                value: "granian"
              - name: DATABASE_URL
                value: "postgresql+psycopg://postgres:{{ lookup('amazon.aws.secretsmanager_secret',
                  prefix_v + '-postgres-master-user-password') }}@{{ rds_cluster_info_r.clusters[0].endpoint }}:5432/mcp"
              - name: REDIS_URL
                value: "rediss://mcfuser:{{ redis_auth_token }}@{{ elasticache_endpoint }}:6379/0"
              - name: CACHE_TYPE
                value: "redis"
              - name: AUTH_REQUIRED
                value: "true"
              - name: LOG_LEVEL
                value: "ERROR"
              - name: GRANIAN_WORKERS
                value: "16"
              - name: GRANIAN_BACKPRESSURE
                value: "256"
              - name: DB_POOL_CLASS
                value: "queue"
              - name: DB_POOL_SIZE
                value: "20"
              - name: MCP_SESSION_POOL_ENABLED
                value: "true"
              - name: JWT_ALGORITHM
                value: "HS256"
              - name: JWT_SECRET_KEY
                value: "{{ jwt_secret_key_v }}"
              - name: JWT_AUDIENCE
                value: "mcpgateway-api"
              - name: JWT_ISSUER
                value: "mcpgateway"
              - name: PLATFORM_ADMIN_EMAIL
                value: "admin@example.com"
              - name: PLATFORM_ADMIN_PASSWORD
                value: "{{ platform_admin_password_v | default('changeme') }}"
              - name: MCPGATEWAY_UI_ENABLED
                value: "false"  # Until we patch the cache to just forward admin requests
            portMappings:
              - name: gateway
                containerPort: 4444
                protocol: tcp
      register: gateway_td_r

    - name: ECS Task Definition for nginx
      community.aws.ecs_taskdefinition:
        family: "{{ prefix_v }}-nginx-td"
        state: "present"
        launch_type: FARGATE
        memory: "2048"
        cpu: "1024"
        network_mode: awsvpc
        execution_role_arn: "{{ execution_role_r.iam_role.arn }}"
        task_role_arn: "{{ task_role_r.iam_role.arn }}"
        force_create: true
        containers:
          - name: nginx
            image: >-
              {{ ecr_registry }}/{{ prefix_v }}/mcp-context-forge-nginx:{{ nginx_image_tag_v | default('latest') }}
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: nginx
            environment:
              - name: GATEWAY_HOST
                value: "gateway.{{ prefix_v }}.local"
              - name: GATEWAY_PORT
                value: "4444"
            portMappings:
              - name: nginx
                containerPort: 80
                protocol: tcp
      register: nginx_td_r

    - name: ECS Task Definition for fast-time-server
      community.aws.ecs_taskdefinition:
        family: "{{ prefix_v }}-fast-time-td"
        state: "present"
        launch_type: FARGATE
        memory: "1024"
        cpu: "512"
        network_mode: awsvpc
        execution_role_arn: "{{ execution_role_r.iam_role.arn }}"
        task_role_arn: "{{ task_role_r.iam_role.arn }}"
        force_create: true
        containers:
          - name: fast-time-server
            image: "ghcr.io/ibm/fast-time-server:latest"
            essential: true
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: fast-time
            command:
              - "-transport=dual"
              - "-listen=0.0.0.0"
              - "-port=8080"
              - "-log-level=info"
            portMappings:
              - name: fast-time
                containerPort: 8080
                protocol: tcp
          - name: register-fast-time
            image: "ghcr.io/ibm/mcp-context-forge:{{ gateway_image_tag_v | default('latest') }}"
            essential: false
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: register-fast-time
            environment:
              - name: JWT_SECRET_KEY
                value: "{{ jwt_secret_key_v }}"
              - name: GATEWAY_URL
                value: "http://gateway.{{ prefix_v }}.local:4444"
              - name: MCP_SERVER_URL
                value: "http://localhost:8080/http"
              - name: MCP_SERVER_NAME
                value: "fast_time"
            entryPoint:
              - "/bin/sh"
              - "-c"
            command:
              - |
                echo "Waiting for gateway..."
                for i in $(seq 1 60); do
                  if python3 -c "import urllib.request; urllib.request.urlopen('$GATEWAY_URL/health', timeout=2)" 2>/dev/null; then
                    echo "Gateway is ready"
                    break
                  fi
                  echo "Waiting... ($i/60)"
                  sleep 5
                done
                echo "Waiting for fast-time-server..."
                for i in $(seq 1 30); do
                  if python3 -c "import urllib.request; urllib.request.urlopen('http://localhost:8080/health', timeout=2)" 2>/dev/null; then
                    echo "fast-time-server is ready"
                    break
                  fi
                  echo "Waiting... ($i/30)"
                  sleep 2
                done
                echo "Generating JWT and registering..."
                export MCPGATEWAY_BEARER_TOKEN=$(python3 -m mcpgateway.utils.create_jwt_token --username admin@example.com --exp 10080 --secret "$JWT_SECRET_KEY" --algo HS256 2>/dev/null)
                python3 -c "
                import urllib.request, json, os
                token = os.environ['MCPGATEWAY_BEARER_TOKEN']
                gateway_url = os.environ['GATEWAY_URL']
                def api(method, path, data=None):
                    req = urllib.request.Request(f'{gateway_url}{path}', method=method)
                    req.add_header('Authorization', f'Bearer {token}')
                    req.add_header('Content-Type', 'application/json')
                    if data: req.data = json.dumps(data).encode()
                    with urllib.request.urlopen(req, timeout=30) as r: return json.loads(r.read())
                try:
                    for gw in api('GET', '/gateways'):
                        if gw.get('name') == 'fast_time':
                            api('DELETE', f'/gateways/{gw[\"id\"]}')
                            print('Deleted existing gateway')
                except: pass
                result = api('POST', '/gateways', {'name': 'fast_time', 'url': os.environ['MCP_SERVER_URL'], 'transport': 'STREAMABLEHTTP'})
                print(f'Registered: {result.get(\"id\", \"unknown\")}')
                "
                echo "Registration complete"
      register: fast_time_td_r

    - name: ECS Task Definition for fast-test-server
      community.aws.ecs_taskdefinition:
        family: "{{ prefix_v }}-fast-test-td"
        state: "present"
        launch_type: FARGATE
        memory: "1024"
        cpu: "512"
        network_mode: awsvpc
        execution_role_arn: "{{ execution_role_r.iam_role.arn }}"
        task_role_arn: "{{ task_role_r.iam_role.arn }}"
        force_create: true
        containers:
          - name: fast-test-server
            image: "{{ ecr_registry }}/{{ prefix_v }}/fast-test-server:latest"
            essential: true
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: fast-test
            environment:
              - name: BIND_ADDRESS
                value: "0.0.0.0:8880"
              - name: RUST_LOG
                value: "info"
            portMappings:
              - name: fast-test
                containerPort: 8880
                protocol: tcp
          - name: register-fast-test
            image: "ghcr.io/ibm/mcp-context-forge:{{ gateway_image_tag_v | default('latest') }}"
            essential: false
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: register-fast-test
            environment:
              - name: JWT_SECRET_KEY
                value: "{{ jwt_secret_key_v }}"
              - name: GATEWAY_URL
                value: "http://gateway.{{ prefix_v }}.local:4444"
              - name: MCP_SERVER_URL
                value: "http://localhost:8880/mcp"
              - name: MCP_SERVER_NAME
                value: "fast_test"
            entryPoint:
              - "/bin/sh"
              - "-c"
            command:
              - |
                echo "Waiting for gateway..."
                for i in $(seq 1 60); do
                  if python3 -c "import urllib.request; urllib.request.urlopen('$GATEWAY_URL/health', timeout=2)" 2>/dev/null; then
                    echo "Gateway is ready"
                    break
                  fi
                  echo "Waiting... ($i/60)"
                  sleep 5
                done
                echo "Waiting for fast-test-server..."
                for i in $(seq 1 30); do
                  if python3 -c "import urllib.request; urllib.request.urlopen('http://localhost:8880/health', timeout=2)" 2>/dev/null; then
                    echo "fast-test-server is ready"
                    break
                  fi
                  echo "Waiting... ($i/30)"
                  sleep 2
                done
                echo "Generating JWT and registering..."
                export MCPGATEWAY_BEARER_TOKEN=$(python3 -m mcpgateway.utils.create_jwt_token --username admin@example.com --exp 10080 --secret "$JWT_SECRET_KEY" --algo HS256 2>/dev/null)
                python3 -c "
                import urllib.request, json, os
                token = os.environ['MCPGATEWAY_BEARER_TOKEN']
                gateway_url = os.environ['GATEWAY_URL']
                def api(method, path, data=None):
                    req = urllib.request.Request(f'{gateway_url}{path}', method=method)
                    req.add_header('Authorization', f'Bearer {token}')
                    req.add_header('Content-Type', 'application/json')
                    if data: req.data = json.dumps(data).encode()
                    with urllib.request.urlopen(req, timeout=30) as r: return json.loads(r.read())
                try:
                    for gw in api('GET', '/gateways'):
                        if gw.get('name') == 'fast_test':
                            api('DELETE', f'/gateways/{gw[\"id\"]}')
                            print('Deleted existing gateway')
                except: pass
                result = api('POST', '/gateways', {'name': 'fast_test', 'url': os.environ['MCP_SERVER_URL'], 'transport': 'STREAMABLEHTTP'})
                print(f'Registered: {result.get(\"id\", \"unknown\")}')
                "
                echo "Registration complete"
      register: fast_test_td_r

    - name: ECS Task Definition for benchmark-server
      community.aws.ecs_taskdefinition:
        family: "{{ prefix_v }}-benchmark-td"
        state: "present"
        launch_type: FARGATE
        memory: "2048"
        cpu: "1024"
        network_mode: awsvpc
        execution_role_arn: "{{ execution_role_r.iam_role.arn }}"
        task_role_arn: "{{ task_role_r.iam_role.arn }}"
        force_create: true
        containers:
          - name: benchmark-server
            image: "{{ ecr_registry }}/{{ prefix_v }}/benchmark-server:latest"
            essential: true
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: benchmark
            command:
              - "-transport=http"
              - "-server-count={{ benchmark_server_count | default(10) | string }}"
              - "-start-port=9000"
              - "-tools=50"
              - "-resources=20"
              - "-prompts=10"
            portMappings:
              - name: benchmark
                containerPort: 9000
                protocol: tcp
          - name: register-benchmark
            image: "ghcr.io/ibm/mcp-context-forge:{{ gateway_image_tag_v | default('latest') }}"
            essential: false
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: /ecs/mcf
                awslogs-region: "{{ region_v }}"
                awslogs-stream-prefix: register-benchmark
            environment:
              - name: JWT_SECRET_KEY
                value: "{{ jwt_secret_key_v }}"
              - name: GATEWAY_URL
                value: "http://gateway.{{ prefix_v }}.local:4444"
              - name: BENCHMARK_SERVER_COUNT
                value: "{{ benchmark_server_count | default(10) | string }}"
            entryPoint:
              - "/bin/sh"
              - "-c"
            command:
              - |
                echo "Waiting for gateway..."
                for i in $(seq 1 60); do
                  if python3 -c "import urllib.request; urllib.request.urlopen('$GATEWAY_URL/health', timeout=2)" 2>/dev/null; then
                    echo "Gateway is ready"
                    break
                  fi
                  echo "Waiting... ($i/60)"
                  sleep 5
                done
                echo "Waiting for benchmark-server..."
                sleep 10
                echo "Generating JWT and registering benchmark servers..."
                export MCPGATEWAY_BEARER_TOKEN=$(python3 -m mcpgateway.utils.create_jwt_token --username admin@example.com --exp 10080 --secret "$JWT_SECRET_KEY" --algo HS256 2>/dev/null)
                python3 -c "
                import urllib.request, json, os
                token = os.environ['MCPGATEWAY_BEARER_TOKEN']
                gateway_url = os.environ['GATEWAY_URL']
                server_count = int(os.environ.get('BENCHMARK_SERVER_COUNT', '10'))
                def api(method, path, data=None):
                    req = urllib.request.Request(f'{gateway_url}{path}', method=method)
                    req.add_header('Authorization', f'Bearer {token}')
                    req.add_header('Content-Type', 'application/json')
                    if data: req.data = json.dumps(data).encode()
                    with urllib.request.urlopen(req, timeout=30) as r: return json.loads(r.read())
                registered = 0
                for port in range(9000, 9000 + server_count):
                    name = f'benchmark-{port}'
                    try:
                        result = api('POST', '/gateways', {'name': name, 'url': f'http://localhost:{port}/mcp', 'transport': 'STREAMABLEHTTP'})
                        print(f'Registered {name}: {result.get(\"id\", \"unknown\")}')
                        registered += 1
                    except Exception as e:
                        if '409' in str(e): registered += 1
                        else: print(f'Failed {name}: {e}')
                print(f'Registered {registered}/{server_count} servers')
                "
                echo "Registration complete"
      register: benchmark_td_r

    # ==========================================================================
    # ECS Services
    # ==========================================================================

    - name: Gateway service
      ecs_service:
        state: present
        name: "{{ prefix_v }}-gateway-svc"
        cluster: "{{ prefix_v }}-ecs-cluster"
        launch_type: FARGATE
        desired_count: "{{ gateway_replicas | default(3) }}"
        task_definition: "{{ gateway_td_r.taskdefinition.taskDefinitionArn }}"
        network_configuration:
          assign_public_ip: false
          subnets: "{{ vpc_private_subnets_r.subnets | map(attribute='id') }}"
          security_groups:
            - "{{ ecs_ec2_sg_group_id_f }}"
        enable_execute_command: "{{ debug_container_p }}"
        service_connect_configuration:
          enabled: true
          namespace: "{{ prefix_v }}.local"
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: /ecs/mcf
              awslogs-region: "{{ region_v }}"
              awslogs-stream-prefix: gateway-service-connect
          services:
            - port_name: gateway
              client_aliases:
                - port: 4444
                  dns_name: gateway

    - name: Nginx service
      ecs_service:
        state: present
        name: "{{ prefix_v }}-nginx-svc"
        cluster: "{{ prefix_v }}-ecs-cluster"
        launch_type: FARGATE
        desired_count: 1
        task_definition: "{{ nginx_td_r.taskdefinition.taskDefinitionArn }}"
        network_configuration:
          assign_public_ip: false
          subnets: "{{ vpc_private_subnets_r.subnets | map(attribute='id') }}"
          security_groups:
            - "{{ ecs_ec2_sg_group_id_f }}"
        enable_execute_command: "{{ debug_container_p }}"
        service_connect_configuration:
          enabled: true
          namespace: "{{ prefix_v }}.local"
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: /ecs/mcf
              awslogs-region: "{{ region_v }}"
              awslogs-stream-prefix: nginx-service-connect
          services:
            - port_name: nginx
              client_aliases:
                - port: 80
                  dns_name: nginx

    - name: Fast Time Server service
      ecs_service:
        state: present
        name: "{{ prefix_v }}-fast-time-svc"
        cluster: "{{ prefix_v }}-ecs-cluster"
        launch_type: FARGATE
        desired_count: 1
        task_definition: "{{ fast_time_td_r.taskdefinition.taskDefinitionArn }}"
        network_configuration:
          assign_public_ip: false
          subnets: "{{ vpc_private_subnets_r.subnets | map(attribute='id') }}"
          security_groups:
            - "{{ ecs_ec2_sg_group_id_f }}"
        enable_execute_command: "{{ debug_container_p }}"
        service_connect_configuration:
          enabled: true
          namespace: "{{ prefix_v }}.local"
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: /ecs/mcf
              awslogs-region: "{{ region_v }}"
              awslogs-stream-prefix: fast-time-service-connect
          services:
            - port_name: fast-time
              client_aliases:
                - port: 8080
                  dns_name: fast-time

    - name: Fast Test Server service
      ecs_service:
        state: present
        name: "{{ prefix_v }}-fast-test-svc"
        cluster: "{{ prefix_v }}-ecs-cluster"
        launch_type: FARGATE
        desired_count: 1
        task_definition: "{{ fast_test_td_r.taskdefinition.taskDefinitionArn }}"
        network_configuration:
          assign_public_ip: false
          subnets: "{{ vpc_private_subnets_r.subnets | map(attribute='id') }}"
          security_groups:
            - "{{ ecs_ec2_sg_group_id_f }}"
        enable_execute_command: "{{ debug_container_p }}"
        service_connect_configuration:
          enabled: true
          namespace: "{{ prefix_v }}.local"
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: /ecs/mcf
              awslogs-region: "{{ region_v }}"
              awslogs-stream-prefix: fast-test-service-connect
          services:
            - port_name: fast-test
              client_aliases:
                - port: 8880
                  dns_name: fast-test

    - name: Benchmark Server service
      ecs_service:
        state: present
        name: "{{ prefix_v }}-benchmark-svc"
        cluster: "{{ prefix_v }}-ecs-cluster"
        launch_type: FARGATE
        desired_count: 1
        task_definition: "{{ benchmark_td_r.taskdefinition.taskDefinitionArn }}"
        network_configuration:
          assign_public_ip: false
          subnets: "{{ vpc_private_subnets_r.subnets | map(attribute='id') }}"
          security_groups:
            - "{{ ecs_ec2_sg_group_id_f }}"
        enable_execute_command: "{{ debug_container_p }}"
        service_connect_configuration:
          enabled: true
          namespace: "{{ prefix_v }}.local"
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: /ecs/mcf
              awslogs-region: "{{ region_v }}"
              awslogs-stream-prefix: benchmark-service-connect
          services:
            - port_name: benchmark
              client_aliases:
                - port: 9000
                  dns_name: benchmark

    # ==========================================================================
    # Wait and Configure DNS
    # ==========================================================================

    - name: Wait for the services to be available in Cloud Map
      cloudmap_info:
        namespace_name: "{{ prefix_v }}.local"
        service_name: "{{ item }}"
        include_instances: true
      register: cloudmap_info_r
      retries: 30
      delay: 20
      until: "('services' in cloudmap_info_r)
        and (cloudmap_info_r.services
          | map(attribute='instances') | flatten
          | map(attribute='ipv4') | flatten)
        is truthy"
      loop:
        - gateway
        - nginx
        - fast-time
        - fast-test
        - benchmark
